# Pending Learning Review

**ID:** L001
**Created:** 2025-12-29 09:00
**Session:** test-session-001
**Status:** approved

---

## Summary

**Title:** Context Timeout for External API Calls
**Type:** anti-pattern
**Severity:** HIGH
**Confidence:** high

---

## Content

### Discovery

External API calls (OpenAI, HTTP clients, database queries) without context timeout can hang forever, causing:
- Goroutine leaks (blocked goroutines never exit)
- Resource exhaustion (connections never released)
- Cascading failures (one slow service blocks everything)

### Evidence

- Occurrence 1: `examples/chatbot-memory/main.go` - OpenAI call without timeout
- Occurrence 2: `examples/multi-agent-orchestrator/main.go` - HTTP client without timeout
- Occurrence 3: Common pattern in LLM integration code

### Code Example

```go
// WRONG: No timeout, can hang forever
func callOpenAI(client *openai.Client, prompt string) (string, error) {
    resp, err := client.CreateChatCompletion(
        context.Background(), // PROBLEM: no timeout!
        openai.ChatCompletionRequest{
            Model: "gpt-4",
            Messages: []openai.ChatCompletionMessage{
                {Role: "user", Content: prompt},
            },
        },
    )
    return resp.Choices[0].Message.Content, err
}

// CORRECT: Always use timeout for external calls
func callOpenAI(ctx context.Context, client *openai.Client, prompt string) (string, error) {
    ctx, cancel := context.WithTimeout(ctx, 30*time.Second)
    defer cancel()

    resp, err := client.CreateChatCompletion(ctx, openai.ChatCompletionRequest{
        Model: "gpt-4",
        Messages: []openai.ChatCompletionMessage{
            {Role: "user", Content: prompt},
        },
    })
    if err != nil {
        return "", fmt.Errorf("openai call failed: %w", err)
    }
    return resp.Choices[0].Message.Content, nil
}
```

### Proposed Knowledge Entry

**Target File:** `10-learned-anti-patterns.md`
**Target Section:** Resource Management Anti-Patterns

```markdown
### Anti-Pattern: External API Call Without Timeout

**Discovered:** 2025-12-29
**Source:** Code review
**Severity:** HIGH
**Occurrences:** 3+ times caught

**The Problem:**
```go
// BROKEN: This can hang forever
resp, err := client.CreateChatCompletion(
    context.Background(), // No timeout!
    request,
)
```

**Why It's Wrong:**
1. External services can be slow or unresponsive
2. Goroutine blocks indefinitely waiting for response
3. Resources (connections, memory) never released
4. One slow call can cascade to system-wide failure

**The Solution:**
```go
// CORRECT: Always timeout external calls
ctx, cancel := context.WithTimeout(ctx, 30*time.Second)
defer cancel()

resp, err := client.CreateChatCompletion(ctx, request)
```

**Recommended Timeouts:**
| Service Type | Timeout |
|--------------|---------|
| LLM API (OpenAI, Claude) | 30-60s |
| REST API | 10s |
| Database query | 5s |
| Health check | 2s |

**Detection:** Search for `context.Background()` or `context.TODO()` in API call sites.

**Related:** [04-http-patterns.md](./04-http-patterns.md), [06-concurrency.md](./06-concurrency.md)
```

---

## Review Decision

**Reviewer:** Human (via *learn-approve:L001)
**Date:** 2025-12-29 09:50
**Decision:** APPROVED

**Notes:**
Essential pattern for LLM integrations - context timeout prevents hung goroutines.
Added to 10-learned-anti-patterns.md under Resource Management section.
