# Pending Learning Review

**ID:** L002
**Created:** 2025-12-29 09:30
**Session:** test-session-001
**Status:** approved

---

## Summary

**Title:** Signal Handler Goroutine Leak
**Type:** bugfix
**Severity:** CRITICAL
**Confidence:** high

---

## Content

### Discovery

Signal handler goroutines that wait on `signal.Notify` channel without context cancellation support will leak - they block forever if no signal is received before shutdown.

### Evidence

- Occurrence 1: `signal/engine.go` - Original implementation leaked on graceful shutdown
- Occurrence 2: Found during testing with `-race` flag
- Root cause: `select` only waited on signal channel, not context

### Code Example

```go
// WRONG: Leaks goroutine if context cancelled before signal
func handleSignals(ctx context.Context) {
    sigCh := make(chan os.Signal, 1)
    signal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM)

    go func() {
        <-sigCh // Blocks FOREVER if no signal received!
        fmt.Println("Signal received")
    }()
}

// CORRECT: Exits cleanly on context cancellation
func handleSignals(ctx context.Context) {
    sigCh := make(chan os.Signal, 1)
    signal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM)

    go func() {
        defer signal.Stop(sigCh) // CRITICAL: Stop receiving signals

        select {
        case sig := <-sigCh:
            fmt.Printf("Signal received: %v\n", sig)
            // Handle signal...
        case <-ctx.Done():
            // Context cancelled, exit cleanly
            fmt.Println("Signal handler: context cancelled, exiting")
            return
        }
    }()
}
```

### Proposed Knowledge Entry

**Target File:** `10-learned-anti-patterns.md`
**Target Section:** Concurrency Anti-Patterns

```markdown
### Anti-Pattern: Signal Handler Without Exit Path

**Discovered:** 2025-12-29
**Source:** Bug fix during testing
**Severity:** CRITICAL
**Occurrences:** Found via race detector

**The Problem:**
```go
// BROKEN: Goroutine leaks on graceful shutdown
go func() {
    sigCh := make(chan os.Signal, 1)
    signal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM)
    <-sigCh // Blocks forever if no signal!
}()
```

**Why It's Wrong:**
1. Goroutine blocks indefinitely on signal channel
2. If program exits via context cancellation (not signal), goroutine leaks
3. `signal.Stop()` never called, OS resources not released
4. Race detector may flag this in tests

**The Solution:**
```go
// CORRECT: Always have exit path via context
go func() {
    sigCh := make(chan os.Signal, 1)
    signal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM)
    defer signal.Stop(sigCh) // Always cleanup!

    select {
    case sig := <-sigCh:
        // Handle signal
    case <-ctx.Done():
        // Exit cleanly on context cancel
        return
    }
}()
```

**Key Rules:**
1. Signal handlers MUST check `ctx.Done()` in select
2. ALWAYS call `signal.Stop(sigCh)` on cleanup (use defer)
3. Buffer signal channel (`make(chan os.Signal, 1)`)

**Detection:** Search for `signal.Notify` without corresponding `signal.Stop` or context check.

**Related:** [02-graceful-shutdown.md](./02-graceful-shutdown.md)
```

---

## Review Decision

**Reviewer:** Human (via *learn-approve:L002)
**Date:** 2025-12-29 09:40
**Decision:** APPROVED

**Notes:**
Critical bug fix - signal handler goroutine leak is a common and serious issue.
Added to 10-learned-anti-patterns.md under Concurrency Anti-Patterns section.
